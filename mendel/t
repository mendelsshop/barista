#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use clap::{Parser, Subcommand};
use config::{BlendConfig, Config};
use craft::create_new_brew;
use serde::de::value::BoolDeserializer;
use crate::mix::add_dependency;
mod config {
    use std::{collections::HashMap, fs, io::Read, path::PathBuf};
    use serde::{Deserialize, Serialize};
    pub struct Config {
        brew: BrewConfig,
        blends: HashMap<String, BlendConfig>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Config {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "brew" => _serde::__private::Ok(__Field::__field0),
                            "blends" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"brew" => _serde::__private::Ok(__Field::__field0),
                            b"blends" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Config>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Config;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Config",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            BrewConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Config with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            HashMap<String, BlendConfig>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Config with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Config {
                            brew: __field0,
                            blends: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<BrewConfig> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            HashMap<String, BlendConfig>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key)
                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("brew"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<BrewConfig>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("blends"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            HashMap<String, BlendConfig>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("brew")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("blends")?
                            }
                        };
                        _serde::__private::Ok(Config {
                            brew: __field0,
                            blends: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["brew", "blends"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Config",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Config>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Config {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Config",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "brew",
                    &self.brew,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "blends",
                    &self.blends,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Config {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Config",
                "brew",
                &self.brew,
                "blends",
                &&self.blends,
            )
        }
    }
    pub struct BrewConfig {
        name: String,
        version: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BrewConfig {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "version" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"version" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BrewConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BrewConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BrewConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BrewConfig with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BrewConfig with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BrewConfig {
                            name: __field0,
                            version: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key)
                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "version",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("version")?
                            }
                        };
                        _serde::__private::Ok(BrewConfig {
                            name: __field0,
                            version: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["name", "version"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BrewConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<BrewConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BrewConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BrewConfig",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "version",
                    &self.version,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for BrewConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "BrewConfig",
                "name",
                &self.name,
                "version",
                &&self.version,
            )
        }
    }
    pub struct BlendConfig {
        author: Option<String>,
        path: Option<String>,
        version: Option<String>,
        url: Option<String>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BlendConfig {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "author" => _serde::__private::Ok(__Field::__field0),
                            "path" => _serde::__private::Ok(__Field::__field1),
                            "version" => _serde::__private::Ok(__Field::__field2),
                            "url" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"author" => _serde::__private::Ok(__Field::__field0),
                            b"path" => _serde::__private::Ok(__Field::__field1),
                            b"version" => _serde::__private::Ok(__Field::__field2),
                            b"url" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BlendConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BlendConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BlendConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BlendConfig with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BlendConfig with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct BlendConfig with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct BlendConfig with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BlendConfig {
                            author: __field0,
                            path: __field1,
                            version: __field2,
                            url: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key)
                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("author"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("path"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "version",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("author")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("path")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("version")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("url")?
                            }
                        };
                        _serde::__private::Ok(BlendConfig {
                            author: __field0,
                            path: __field1,
                            version: __field2,
                            url: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "author",
                    "path",
                    "version",
                    "url",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BlendConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<BlendConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BlendConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BlendConfig",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "author",
                    &self.author,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "path",
                    &self.path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "version",
                    &self.version,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "url",
                    &self.url,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for BlendConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "BlendConfig",
                "author",
                &self.author,
                "path",
                &self.path,
                "version",
                &self.version,
                "url",
                &&self.url,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlendConfig {
        #[inline]
        fn clone(&self) -> BlendConfig {
            BlendConfig {
                author: ::core::clone::Clone::clone(&self.author),
                path: ::core::clone::Clone::clone(&self.path),
                version: ::core::clone::Clone::clone(&self.version),
                url: ::core::clone::Clone::clone(&self.url),
            }
        }
    }
    impl BlendConfig {
        pub fn new_maven(version: String, author: String) -> Self {
            Self {
                author: Some(author),
                path: None,
                version: Some(version),
                url: None,
            }
        }
        pub fn new_git(version: String, url: String) -> Self {
            Self {
                author: None,
                path: None,
                version: Some(version),
                url: Some(url),
            }
        }
        pub fn new_path(version: String, path: String) -> Self {
            Self {
                author: None,
                path: Some(path),
                version: Some(version),
                url: None,
            }
        }
    }
    impl Config {
        /// Create a new config with the given name
        pub fn new(name: String) -> Self {
            Self {
                brew: BrewConfig {
                    name,
                    version: "0.1.0".to_string(),
                },
                blends: HashMap::new(),
            }
        }
        /// Tries to find a config file in the current directory or any of its ancestors
        pub fn find_config() -> Option<PathBuf> {
            std::env::current_dir()
                .ok()?
                .ancestors()
                .find_map(|dir| {
                    if let Ok(mut dir) = dir.read_dir() {
                        dir.find_map(|file| {
                            if let Ok(file) = file {
                                if let Ok(file_type) = file.file_type() {
                                    if file_type.is_file() && file.path().ends_with("brew.toml")
                                    {
                                        return Some(file.path());
                                    }
                                }
                            }
                            None
                        })
                    } else {
                        None
                    }
                })
        }
        pub fn open_config(path: PathBuf) -> Option<Self> {
            match fs::File::open(path) {
                Ok(mut main) => {
                    let mut buf = String::new();
                    if let Err(_) = main.read_to_string(&mut buf) {
                        None
                    } else {
                        let toml = toml::from_str(&buf).ok()?;
                        toml
                    }
                }
                Err(_) => None,
            }
        }
        pub fn find_and_open_config() -> Option<Self> {
            Config::find_config().map(|p| Config::open_config(p)).flatten()
        }
        pub fn add_blend(&mut self, name: String, blend: BlendConfig) {
            self.blends.insert(name, blend);
        }
    }
}
mod craft {
    //! craft.rs handles creating new brews and initializing non-barista projects as brews
    const PSVM: &'static str = r#"public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}"#;
    use std::fs;
    use std::io::Write;
    use crate::config;
    pub fn create_new_brew(name: &str) {
        if let Err(e) = fs::create_dir(&name) {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Error creating directory {0} in creation of new Brew {0}: {1}",
                        name,
                        e,
                    ),
                );
            };
        }
        init_brew(name, name)
    }
    pub fn init_brew(path: &str, name: &str) {
        if let Err(e)
            = fs::create_dir({
                let res = ::alloc::fmt::format(format_args!("{0}/src", path));
                res
            }) {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Error creating source directory in creation of new Brew {0}: {1}",
                        path,
                        e,
                    ),
                );
            };
        }
        init_main(path);
        init_config(path, name);
    }
    fn init_config(path: &str, name: &str) {
        match fs::File::options()
            .write(true)
            .create(true)
            .open({
                let res = ::alloc::fmt::format(format_args!("{0}/brew.toml", path));
                res
            })
        {
            Ok(mut config_file) => {
                let config = config::Config::new(name.to_string());
                if let Err(e)
                    = config_file
                        .write_fmt(
                            format_args!("{0}\n", toml::to_string(&config).unwrap()),
                        )
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Error initializing brew.toml file could not write default config to file: {0}",
                                e,
                            ),
                        );
                    }
                }
            }
            Err(e) => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Error initializing brew.toml file could not create brew.toml file: {0}",
                        e,
                    ),
                );
            }
        }
    }
    fn init_main(path: &str) {
        match fs::File::options()
            .create(true)
            .write(true)
            .open({
                let res = ::alloc::fmt::format(format_args!("{0}/src/Main.java", path));
                res
            })
        {
            Ok(mut main) => {
                if let Err(e) = main.write_fmt(format_args!("{0}\n", PSVM)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Error initializing Main.java file could not write hello world implementation to file: {0}",
                                e,
                            ),
                        );
                    }
                }
            }
            Err(e) => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Error initializing Main.java file could not create Main.java file: {0}",
                        e,
                    ),
                );
            }
        }
    }
}
mod mix {
    use crate::config::{BlendConfig, Config};
    use std::fs;
    use std::io::Write;
    pub fn add_dependency(name: &str, blend: BlendConfig) {
        let config_file = Config::find_config();
        let mut config = config_file
            .clone()
            .map(Config::open_config)
            .flatten()
            .expect("Couldn't find configuration");
        config.add_blend(name.to_string(), blend);
        match fs::OpenOptions::new().write(true).open(config_file.unwrap()) {
            Ok(mut file) => {
                if let Err(e)
                    = file
                        .write_fmt(
                            format_args!("{0}\n", toml::to_string(&config).unwrap()),
                        )
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Error initializing brew.toml file could not write default config to file: {0}",
                                e,
                            ),
                        );
                    }
                }
            }
            Err(e) => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Error config file moved since last read in middle of adding Blend {0} {1}",
                        name,
                        e,
                    ),
                );
            }
        }
    }
}
#[clap(author, version, about, long_about = None)]
struct Args {
    #[clap(subcommand)]
    command: CommandType,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl clap::Parser for Args {}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::CommandFactory for Args {
    fn command<'b>() -> clap::Command {
        let __clap_app = clap::Command::new("barista");
        <Self as clap::Args>::augment_args(__clap_app)
    }
    fn command_for_update<'b>() -> clap::Command {
        let __clap_app = clap::Command::new("barista");
        <Self as clap::Args>::augment_args_for_update(__clap_app)
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::FromArgMatches for Args {
    fn from_arg_matches(
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn from_arg_matches_mut(
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        #![allow(deprecated)]
        let v = Args {
            command: {
                <CommandType as clap::FromArgMatches>::from_arg_matches_mut(
                    __clap_arg_matches,
                )?
            },
        };
        ::std::result::Result::Ok(v)
    }
    fn update_from_arg_matches(
        &mut self,
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn update_from_arg_matches_mut(
        &mut self,
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        #![allow(deprecated)]
        {
            #[allow(non_snake_case)]
            let command = &mut self.command;
            <CommandType as clap::FromArgMatches>::update_from_arg_matches_mut(
                command,
                __clap_arg_matches,
            )?;
        }
        ::std::result::Result::Ok(())
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::Args for Args {
    fn group_id() -> Option<clap::Id> {
        Some(clap::Id::from("Args"))
    }
    fn augment_args<'b>(__clap_app: clap::Command) -> clap::Command {
        {
            let __clap_app = __clap_app
                .group(
                    clap::ArgGroup::new("Args")
                        .multiple(true)
                        .args({
                            let members: [clap::Id; 0usize] = [];
                            members
                        }),
                );
            let __clap_app = <CommandType as clap::Subcommand>::augment_subcommands(
                __clap_app,
            );
            let __clap_app = __clap_app
                .subcommand_required(true)
                .arg_required_else_help(true);
            __clap_app.version("0.1.0").long_about(None)
        }
    }
    fn augment_args_for_update<'b>(__clap_app: clap::Command) -> clap::Command {
        {
            let __clap_app = __clap_app
                .group(
                    clap::ArgGroup::new("Args")
                        .multiple(true)
                        .args({
                            let members: [clap::Id; 0usize] = [];
                            members
                        }),
                );
            let __clap_app = <CommandType as clap::Subcommand>::augment_subcommands(
                __clap_app,
            );
            let __clap_app = __clap_app
                .subcommand_required(true)
                .arg_required_else_help(true)
                .subcommand_required(false)
                .arg_required_else_help(false);
            __clap_app.version("0.1.0").long_about(None)
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "Args",
            "command",
            &&self.command,
        )
    }
}
pub enum CommandType {
    /// Build and run the current [Brew] (package)
    Brew,
    /// Build the current [Brew] (package)
    Roast,
    /// Create a new [Brew] (package) with the given name
    Craft { name: String },
    /// Add a new [Blend] (dependency) to the current brew
    Mix {
        /// Blend (dependency) name
        name: String,
        #[clap(default_value = "*")]
        version: String,
    },
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::FromArgMatches for CommandType {
    fn from_arg_matches(
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn from_arg_matches_mut(
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        #![allow(deprecated)]
        if let Some((__clap_name, mut __clap_arg_sub_matches))
            = __clap_arg_matches.remove_subcommand()
        {
            let __clap_arg_matches = &mut __clap_arg_sub_matches;
            if __clap_name == "brew" && !__clap_arg_matches.contains_id("") {
                return ::std::result::Result::Ok(Self::Brew);
            }
            if __clap_name == "roast" && !__clap_arg_matches.contains_id("") {
                return ::std::result::Result::Ok(Self::Roast);
            }
            if __clap_name == "craft" && !__clap_arg_matches.contains_id("") {
                return ::std::result::Result::Ok(Self::Craft {
                    name: __clap_arg_matches
                        .remove_one::<String>("name")
                        .ok_or_else(|| clap::Error::raw(
                            clap::error::ErrorKind::MissingRequiredArgument,
                            "The following required argument was not provided: name",
                        ))?,
                });
            }
            if __clap_name == "mix" && !__clap_arg_matches.contains_id("") {
                return ::std::result::Result::Ok(Self::Mix {
                    name: __clap_arg_matches
                        .remove_one::<String>("name")
                        .ok_or_else(|| clap::Error::raw(
                            clap::error::ErrorKind::MissingRequiredArgument,
                            "The following required argument was not provided: name",
                        ))?,
                    version: __clap_arg_matches
                        .remove_one::<String>("version")
                        .ok_or_else(|| clap::Error::raw(
                            clap::error::ErrorKind::MissingRequiredArgument,
                            "The following required argument was not provided: version",
                        ))?,
                });
            }
            ::std::result::Result::Err(
                clap::Error::raw(
                    clap::error::ErrorKind::InvalidSubcommand,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "The subcommand \'{0}\' wasn\'t recognized",
                                __clap_name,
                            ),
                        );
                        res
                    },
                ),
            )
        } else {
            ::std::result::Result::Err(
                clap::Error::raw(
                    clap::error::ErrorKind::MissingSubcommand,
                    "A subcommand is required but one was not provided.",
                ),
            )
        }
    }
    fn update_from_arg_matches(
        &mut self,
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn update_from_arg_matches_mut<'b>(
        &mut self,
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        #![allow(deprecated)]
        if let Some(__clap_name) = __clap_arg_matches.subcommand_name() {
            match self {
                Self::Brew if "brew" == __clap_name => {
                    let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                        .remove_subcommand()
                        .unwrap();
                    let __clap_arg_matches = &mut __clap_arg_sub_matches;
                    {}
                }
                Self::Roast if "roast" == __clap_name => {
                    let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                        .remove_subcommand()
                        .unwrap();
                    let __clap_arg_matches = &mut __clap_arg_sub_matches;
                    {}
                }
                Self::Craft { name } if "craft" == __clap_name => {
                    let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                        .remove_subcommand()
                        .unwrap();
                    let __clap_arg_matches = &mut __clap_arg_sub_matches;
                    {
                        if __clap_arg_matches.contains_id("name") {
                            *name = __clap_arg_matches
                                .remove_one::<String>("name")
                                .ok_or_else(|| clap::Error::raw(
                                    clap::error::ErrorKind::MissingRequiredArgument,
                                    "The following required argument was not provided: name",
                                ))?;
                        }
                    }
                }
                Self::Mix { name, version } if "mix" == __clap_name => {
                    let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                        .remove_subcommand()
                        .unwrap();
                    let __clap_arg_matches = &mut __clap_arg_sub_matches;
                    {
                        if __clap_arg_matches.contains_id("name") {
                            *name = __clap_arg_matches
                                .remove_one::<String>("name")
                                .ok_or_else(|| clap::Error::raw(
                                    clap::error::ErrorKind::MissingRequiredArgument,
                                    "The following required argument was not provided: name",
                                ))?;
                        }
                        if __clap_arg_matches.contains_id("version") {
                            *version = __clap_arg_matches
                                .remove_one::<String>("version")
                                .ok_or_else(|| clap::Error::raw(
                                    clap::error::ErrorKind::MissingRequiredArgument,
                                    "The following required argument was not provided: version",
                                ))?;
                        }
                    }
                }
                s => {
                    *s = <Self as clap::FromArgMatches>::from_arg_matches_mut(
                        __clap_arg_matches,
                    )?;
                }
            }
        }
        ::std::result::Result::Ok(())
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::Subcommand for CommandType {
    fn augment_subcommands<'b>(__clap_app: clap::Command) -> clap::Command {
        let __clap_app = __clap_app;
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("brew");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = __clap_subcommand;
                __clap_subcommand
                    .about("Build and run the current [Brew] (package)")
                    .long_about(None)
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("roast");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = __clap_subcommand;
                __clap_subcommand
                    .about("Build the current [Brew] (package)")
                    .long_about(None)
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("craft");
                {
                    let __clap_subcommand = __clap_subcommand
                        .group(
                            clap::ArgGroup::new("Craft")
                                .multiple(true)
                                .args({
                                    let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                    members
                                }),
                        );
                    let __clap_subcommand = __clap_subcommand
                        .arg({
                            #[allow(deprecated)]
                            let arg = clap::Arg::new("name")
                                .value_name("NAME")
                                .required(true && clap::ArgAction::Set.takes_values())
                                .value_parser({
                                    use ::clap_builder::builder::via_prelude::*;
                                    let auto = ::clap_builder::builder::_AutoValueParser::<
                                        String,
                                    >::new();
                                    (&&&&&&auto).value_parser()
                                })
                                .action(clap::ArgAction::Set);
                            let arg = arg;
                            let arg = arg;
                            arg
                        });
                    __clap_subcommand
                        .about("Create a new [Brew] (package) with the given name")
                        .long_about(None)
                }
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("mix");
                {
                    let __clap_subcommand = __clap_subcommand
                        .group(
                            clap::ArgGroup::new("Mix")
                                .multiple(true)
                                .args({
                                    let members: [clap::Id; 2usize] = [
                                        clap::Id::from("name"),
                                        clap::Id::from("version"),
                                    ];
                                    members
                                }),
                        );
                    let __clap_subcommand = __clap_subcommand
                        .arg({
                            #[allow(deprecated)]
                            let arg = clap::Arg::new("name")
                                .value_name("NAME")
                                .required(true && clap::ArgAction::Set.takes_values())
                                .value_parser({
                                    use ::clap_builder::builder::via_prelude::*;
                                    let auto = ::clap_builder::builder::_AutoValueParser::<
                                        String,
                                    >::new();
                                    (&&&&&&auto).value_parser()
                                })
                                .action(clap::ArgAction::Set);
                            let arg = arg
                                .help("Blend (dependency) name")
                                .long_help(None);
                            let arg = arg;
                            arg
                        });
                    let __clap_subcommand = __clap_subcommand
                        .arg({
                            #[allow(deprecated)]
                            let arg = clap::Arg::new("version")
                                .value_name("VERSION")
                                .required(false && clap::ArgAction::Set.takes_values())
                                .value_parser({
                                    use ::clap_builder::builder::via_prelude::*;
                                    let auto = ::clap_builder::builder::_AutoValueParser::<
                                        String,
                                    >::new();
                                    (&&&&&&auto).value_parser()
                                })
                                .action(clap::ArgAction::Set);
                            let arg = arg.default_value("*");
                            let arg = arg;
                            arg
                        });
                    __clap_subcommand
                        .about("Add a new [Blend] (dependency) to the current brew")
                        .long_about(None)
                }
            });
        __clap_app
    }
    fn augment_subcommands_for_update<'b>(__clap_app: clap::Command) -> clap::Command {
        let __clap_app = __clap_app;
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("brew");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = __clap_subcommand;
                __clap_subcommand
                    .about("Build and run the current [Brew] (package)")
                    .long_about(None)
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("roast");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = __clap_subcommand;
                __clap_subcommand
                    .about("Build the current [Brew] (package)")
                    .long_about(None)
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("craft");
                {
                    let __clap_subcommand = __clap_subcommand
                        .group(
                            clap::ArgGroup::new("Craft")
                                .multiple(true)
                                .args({
                                    let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                    members
                                }),
                        );
                    let __clap_subcommand = __clap_subcommand
                        .arg({
                            #[allow(deprecated)]
                            let arg = clap::Arg::new("name")
                                .value_name("NAME")
                                .required(true && clap::ArgAction::Set.takes_values())
                                .value_parser({
                                    use ::clap_builder::builder::via_prelude::*;
                                    let auto = ::clap_builder::builder::_AutoValueParser::<
                                        String,
                                    >::new();
                                    (&&&&&&auto).value_parser()
                                })
                                .action(clap::ArgAction::Set);
                            let arg = arg;
                            let arg = arg.required(false);
                            arg
                        });
                    __clap_subcommand
                        .about("Create a new [Brew] (package) with the given name")
                        .long_about(None)
                }
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("mix");
                {
                    let __clap_subcommand = __clap_subcommand
                        .group(
                            clap::ArgGroup::new("Mix")
                                .multiple(true)
                                .args({
                                    let members: [clap::Id; 2usize] = [
                                        clap::Id::from("name"),
                                        clap::Id::from("version"),
                                    ];
                                    members
                                }),
                        );
                    let __clap_subcommand = __clap_subcommand
                        .arg({
                            #[allow(deprecated)]
                            let arg = clap::Arg::new("name")
                                .value_name("NAME")
                                .required(true && clap::ArgAction::Set.takes_values())
                                .value_parser({
                                    use ::clap_builder::builder::via_prelude::*;
                                    let auto = ::clap_builder::builder::_AutoValueParser::<
                                        String,
                                    >::new();
                                    (&&&&&&auto).value_parser()
                                })
                                .action(clap::ArgAction::Set);
                            let arg = arg
                                .help("Blend (dependency) name")
                                .long_help(None);
                            let arg = arg.required(false);
                            arg
                        });
                    let __clap_subcommand = __clap_subcommand
                        .arg({
                            #[allow(deprecated)]
                            let arg = clap::Arg::new("version")
                                .value_name("VERSION")
                                .required(false && clap::ArgAction::Set.takes_values())
                                .value_parser({
                                    use ::clap_builder::builder::via_prelude::*;
                                    let auto = ::clap_builder::builder::_AutoValueParser::<
                                        String,
                                    >::new();
                                    (&&&&&&auto).value_parser()
                                })
                                .action(clap::ArgAction::Set);
                            let arg = arg.default_value("*");
                            let arg = arg.required(false);
                            arg
                        });
                    __clap_subcommand
                        .about("Add a new [Blend] (dependency) to the current brew")
                        .long_about(None)
                }
            });
        __clap_app
    }
    fn has_subcommand(__clap_name: &str) -> bool {
        if "brew" == __clap_name {
            return true;
        }
        if "roast" == __clap_name {
            return true;
        }
        if "craft" == __clap_name {
            return true;
        }
        if "mix" == __clap_name {
            return true;
        }
        false
    }
}
#[automatically_derived]
impl ::core::clone::Clone for CommandType {
    #[inline]
    fn clone(&self) -> CommandType {
        match self {
            CommandType::Brew => CommandType::Brew,
            CommandType::Roast => CommandType::Roast,
            CommandType::Craft { name: __self_0 } => {
                CommandType::Craft {
                    name: ::core::clone::Clone::clone(__self_0),
                }
            }
            CommandType::Mix { name: __self_0, version: __self_1 } => {
                CommandType::Mix {
                    name: ::core::clone::Clone::clone(__self_0),
                    version: ::core::clone::Clone::clone(__self_1),
                }
            }
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for CommandType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            CommandType::Brew => ::core::fmt::Formatter::write_str(f, "Brew"),
            CommandType::Roast => ::core::fmt::Formatter::write_str(f, "Roast"),
            CommandType::Craft { name: __self_0 } => {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Craft",
                    "name",
                    &__self_0,
                )
            }
            CommandType::Mix { name: __self_0, version: __self_1 } => {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Mix",
                    "name",
                    __self_0,
                    "version",
                    &__self_1,
                )
            }
        }
    }
}
pub struct Blend {
    #[clap(flatten)]
    author: Maven,
    #[clap(subcommand)]
    external_blend: Option<BlendType>,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl clap::Parser for Blend {}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::CommandFactory for Blend {
    fn command<'b>() -> clap::Command {
        let __clap_app = clap::Command::new("barista");
        <Self as clap::Args>::augment_args(__clap_app)
    }
    fn command_for_update<'b>() -> clap::Command {
        let __clap_app = clap::Command::new("barista");
        <Self as clap::Args>::augment_args_for_update(__clap_app)
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::FromArgMatches for Blend {
    fn from_arg_matches(
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn from_arg_matches_mut(
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        #![allow(deprecated)]
        let v = Blend {
            author: <Maven as clap::FromArgMatches>::from_arg_matches_mut(
                __clap_arg_matches,
            )?,
            external_blend: {
                if __clap_arg_matches
                    .subcommand_name()
                    .map(<BlendType as clap::Subcommand>::has_subcommand)
                    .unwrap_or(false)
                {
                    Some(
                        <BlendType as clap::FromArgMatches>::from_arg_matches_mut(
                            __clap_arg_matches,
                        )?,
                    )
                } else {
                    None
                }
            },
        };
        ::std::result::Result::Ok(v)
    }
    fn update_from_arg_matches(
        &mut self,
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn update_from_arg_matches_mut(
        &mut self,
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        #![allow(deprecated)]
        {
            #[allow(non_snake_case)]
            let author = &mut self.author;
            <Maven as clap::FromArgMatches>::update_from_arg_matches_mut(
                author,
                __clap_arg_matches,
            )?;
        }
        {
            #[allow(non_snake_case)]
            let external_blend = &mut self.external_blend;
            if let Some(external_blend) = external_blend.as_mut() {
                <BlendType as clap::FromArgMatches>::update_from_arg_matches_mut(
                    external_blend,
                    __clap_arg_matches,
                )?;
            } else {
                *external_blend = Some(
                    <BlendType as clap::FromArgMatches>::from_arg_matches_mut(
                        __clap_arg_matches,
                    )?,
                );
            }
        }
        ::std::result::Result::Ok(())
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::Args for Blend {
    fn group_id() -> Option<clap::Id> {
        Some(clap::Id::from("Blend"))
    }
    fn augment_args<'b>(__clap_app: clap::Command) -> clap::Command {
        {
            let __clap_app = __clap_app
                .group(
                    clap::ArgGroup::new("Blend")
                        .multiple(true)
                        .args({
                            let members: [clap::Id; 0] = [];
                            members
                        }),
                );
            let __clap_app = __clap_app;
            let __clap_app = <Maven as clap::Args>::augment_args(__clap_app);
            let __clap_app = <BlendType as clap::Subcommand>::augment_subcommands(
                __clap_app,
            );
            let __clap_app = __clap_app;
            __clap_app
        }
    }
    fn augment_args_for_update<'b>(__clap_app: clap::Command) -> clap::Command {
        {
            let __clap_app = __clap_app
                .group(
                    clap::ArgGroup::new("Blend")
                        .multiple(true)
                        .args({
                            let members: [clap::Id; 0] = [];
                            members
                        }),
                );
            let __clap_app = __clap_app;
            let __clap_app = <Maven as clap::Args>::augment_args_for_update(__clap_app);
            let __clap_app = <BlendType as clap::Subcommand>::augment_subcommands(
                __clap_app,
            );
            let __clap_app = __clap_app
                .subcommand_required(false)
                .arg_required_else_help(false);
            __clap_app
        }
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Blend {
    #[inline]
    fn clone(&self) -> Blend {
        Blend {
            author: ::core::clone::Clone::clone(&self.author),
            external_blend: ::core::clone::Clone::clone(&self.external_blend),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Blend {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "Blend",
            "author",
            &self.author,
            "external_blend",
            &&self.external_blend,
        )
    }
}
/// Dependencies from Maven Central
pub struct Maven {
    pub author: String,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl clap::Parser for Maven {}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::CommandFactory for Maven {
    fn command<'b>() -> clap::Command {
        let __clap_app = clap::Command::new("barista");
        <Self as clap::Args>::augment_args(__clap_app)
    }
    fn command_for_update<'b>() -> clap::Command {
        let __clap_app = clap::Command::new("barista");
        <Self as clap::Args>::augment_args_for_update(__clap_app)
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::FromArgMatches for Maven {
    fn from_arg_matches(
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn from_arg_matches_mut(
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        #![allow(deprecated)]
        let v = Maven {
            author: __clap_arg_matches
                .remove_one::<String>("author")
                .ok_or_else(|| clap::Error::raw(
                    clap::error::ErrorKind::MissingRequiredArgument,
                    "The following required argument was not provided: author",
                ))?,
        };
        ::std::result::Result::Ok(v)
    }
    fn update_from_arg_matches(
        &mut self,
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn update_from_arg_matches_mut(
        &mut self,
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        #![allow(deprecated)]
        if __clap_arg_matches.contains_id("author") {
            #[allow(non_snake_case)]
            let author = &mut self.author;
            *author = __clap_arg_matches
                .remove_one::<String>("author")
                .ok_or_else(|| clap::Error::raw(
                    clap::error::ErrorKind::MissingRequiredArgument,
                    "The following required argument was not provided: author",
                ))?;
        }
        ::std::result::Result::Ok(())
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::Args for Maven {
    fn group_id() -> Option<clap::Id> {
        Some(clap::Id::from("Maven"))
    }
    fn augment_args<'b>(__clap_app: clap::Command) -> clap::Command {
        {
            let __clap_app = __clap_app
                .group(
                    clap::ArgGroup::new("Maven")
                        .multiple(true)
                        .args({
                            let members: [clap::Id; 1usize] = [clap::Id::from("author")];
                            members
                        }),
                );
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new("author")
                        .value_name("AUTHOR")
                        .required(true && clap::ArgAction::Set.takes_values())
                        .value_parser({
                            use ::clap_builder::builder::via_prelude::*;
                            let auto = ::clap_builder::builder::_AutoValueParser::<
                                String,
                            >::new();
                            (&&&&&&auto).value_parser()
                        })
                        .action(clap::ArgAction::Set);
                    let arg = arg;
                    let arg = arg;
                    arg
                });
            __clap_app.about("Dependencies from Maven Central").long_about(None)
        }
    }
    fn augment_args_for_update<'b>(__clap_app: clap::Command) -> clap::Command {
        {
            let __clap_app = __clap_app
                .group(
                    clap::ArgGroup::new("Maven")
                        .multiple(true)
                        .args({
                            let members: [clap::Id; 1usize] = [clap::Id::from("author")];
                            members
                        }),
                );
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new("author")
                        .value_name("AUTHOR")
                        .required(true && clap::ArgAction::Set.takes_values())
                        .value_parser({
                            use ::clap_builder::builder::via_prelude::*;
                            let auto = ::clap_builder::builder::_AutoValueParser::<
                                String,
                            >::new();
                            (&&&&&&auto).value_parser()
                        })
                        .action(clap::ArgAction::Set);
                    let arg = arg;
                    let arg = arg.required(false);
                    arg
                });
            __clap_app.about("Dependencies from Maven Central").long_about(None)
        }
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Maven {
    #[inline]
    fn clone(&self) -> Maven {
        Maven {
            author: ::core::clone::Clone::clone(&self.author),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Maven {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "Maven",
            "author",
            &&self.author,
        )
    }
}
pub enum BlendType {
    Maven(Maven),
    /// Dependencies from a file located or accesable from your computer
    Path,
    /// Dependencies from a git repository
    Git,
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::FromArgMatches for BlendType {
    fn from_arg_matches(
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn from_arg_matches_mut(
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        #![allow(deprecated)]
        if let Some((__clap_name, mut __clap_arg_sub_matches))
            = __clap_arg_matches.remove_subcommand()
        {
            let __clap_arg_matches = &mut __clap_arg_sub_matches;
            if __clap_name == "maven" && !__clap_arg_matches.contains_id("") {
                return ::std::result::Result::Ok(
                    Self::Maven(
                        <Maven as clap::FromArgMatches>::from_arg_matches_mut(
                            __clap_arg_matches,
                        )?,
                    ),
                );
            }
            if __clap_name == "path" && !__clap_arg_matches.contains_id("") {
                return ::std::result::Result::Ok(Self::Path);
            }
            if __clap_name == "git" && !__clap_arg_matches.contains_id("") {
                return ::std::result::Result::Ok(Self::Git);
            }
            ::std::result::Result::Err(
                clap::Error::raw(
                    clap::error::ErrorKind::InvalidSubcommand,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "The subcommand \'{0}\' wasn\'t recognized",
                                __clap_name,
                            ),
                        );
                        res
                    },
                ),
            )
        } else {
            ::std::result::Result::Err(
                clap::Error::raw(
                    clap::error::ErrorKind::MissingSubcommand,
                    "A subcommand is required but one was not provided.",
                ),
            )
        }
    }
    fn update_from_arg_matches(
        &mut self,
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn update_from_arg_matches_mut<'b>(
        &mut self,
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        #![allow(deprecated)]
        if let Some(__clap_name) = __clap_arg_matches.subcommand_name() {
            match self {
                Self::Maven(ref mut __clap_arg) if "maven" == __clap_name => {
                    let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                        .remove_subcommand()
                        .unwrap();
                    let __clap_arg_matches = &mut __clap_arg_sub_matches;
                    clap::FromArgMatches::update_from_arg_matches_mut(
                        __clap_arg,
                        __clap_arg_matches,
                    )?
                }
                Self::Path if "path" == __clap_name => {
                    let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                        .remove_subcommand()
                        .unwrap();
                    let __clap_arg_matches = &mut __clap_arg_sub_matches;
                    {}
                }
                Self::Git if "git" == __clap_name => {
                    let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                        .remove_subcommand()
                        .unwrap();
                    let __clap_arg_matches = &mut __clap_arg_sub_matches;
                    {}
                }
                s => {
                    *s = <Self as clap::FromArgMatches>::from_arg_matches_mut(
                        __clap_arg_matches,
                    )?;
                }
            }
        }
        ::std::result::Result::Ok(())
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
)]
#[automatically_derived]
impl clap::Subcommand for BlendType {
    fn augment_subcommands<'b>(__clap_app: clap::Command) -> clap::Command {
        let __clap_app = __clap_app;
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("maven");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = {
                    <Maven as clap::Args>::augment_args(__clap_subcommand)
                };
                __clap_subcommand
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("path");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = __clap_subcommand;
                __clap_subcommand
                    .about(
                        "Dependencies from a file located or accesable from your computer",
                    )
                    .long_about(None)
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("git");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = __clap_subcommand;
                __clap_subcommand
                    .about("Dependencies from a git repository")
                    .long_about(None)
            });
        __clap_app
    }
    fn augment_subcommands_for_update<'b>(__clap_app: clap::Command) -> clap::Command {
        let __clap_app = __clap_app;
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("maven");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = {
                    <Maven as clap::Args>::augment_args_for_update(__clap_subcommand)
                };
                __clap_subcommand
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("path");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = __clap_subcommand;
                __clap_subcommand
                    .about(
                        "Dependencies from a file located or accesable from your computer",
                    )
                    .long_about(None)
            });
        let __clap_app = __clap_app
            .subcommand({
                let __clap_subcommand = clap::Command::new("git");
                let __clap_subcommand = __clap_subcommand;
                let __clap_subcommand = __clap_subcommand;
                __clap_subcommand
                    .about("Dependencies from a git repository")
                    .long_about(None)
            });
        __clap_app
    }
    fn has_subcommand(__clap_name: &str) -> bool {
        if "maven" == __clap_name {
            return true;
        }
        if "path" == __clap_name {
            return true;
        }
        if "git" == __clap_name {
            return true;
        }
        false
    }
}
#[automatically_derived]
impl ::core::clone::Clone for BlendType {
    #[inline]
    fn clone(&self) -> BlendType {
        match self {
            BlendType::Maven(__self_0) => {
                BlendType::Maven(::core::clone::Clone::clone(__self_0))
            }
            BlendType::Path => BlendType::Path,
            BlendType::Git => BlendType::Git,
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for BlendType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlendType::Maven(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Maven", &__self_0)
            }
            BlendType::Path => ::core::fmt::Formatter::write_str(f, "Path"),
            BlendType::Git => ::core::fmt::Formatter::write_str(f, "Git"),
        }
    }
}
impl From<Blend> for BlendConfig {
    fn from(value: Blend) -> Self {
        let dep = value.external_blend.unwrap_or(BlendType::Maven(value.author));
        match dep {
            BlendType::Maven(m) => Self::new_maven(value.version, m.author),
            BlendType::Path => ::core::panicking::panic("not yet implemented"),
            BlendType::Git => ::core::panicking::panic("not yet implemented"),
        }
    }
}
fn main() {
    let args = Args::parse();
    match args.command {
        CommandType::Brew => {}
        CommandType::Roast => {}
        CommandType::Craft { name } => create_new_brew(&name),
        CommandType::Mix(blend) => add_dependency(&blend.name.clone(), blend.into()),
    }
    {
        ::std::io::_print(format_args!("{0:?}\n", Config::find_and_open_config()));
    };
}
